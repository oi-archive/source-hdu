{"title":"Data Structure Problem","time_limit":10000,"memory_limit":512,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=6649","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=6649&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=6649","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=6649"},"statement":[{"title":"Problem Description","content":"<pre><br>using namespace std;<br>const unsigned mul = 20190812;<br><br>class Magic {<br>public:<br>  Magic(unsigned state): state(state), ans(0) {}<br><br>  unsigned long long retrieve() {<br>    unsigned modulo = 0x7fffffff;<br>    state = ((unsigned long long) state * mul + ans) % modulo;<br>    unsigned high = state;<br>    state = ((unsigned long long) state * mul + ans) % modulo;<br>    return high * modulo + state;<br>  }<br><br>  int retrieve(int a, int b) {<br>    assert (a &lt;= b);<br>    return (int) (retrieve() % (b - a + 1)) + a;<br>  }<br><br>  void submit(unsigned k) {<br>    ans = ans * mul + k;<br>  }<br>  <br>  unsigned retrieveAns() {<br>    return ans;<br>  }<br><br>private:<br>  unsigned state, ans;<br>};<br><br>class DataStructure {<br>public:<br>  DataStructure() {<br>    // The data structure is initially empty, until it&apos;s not.<br>    // Implement your initialization here.<br>  }<br>  void add(int x, int y) {<br>    // Add a 2D point (x, y) to the DS.<br>    // Implement your add here.<br>  }<br>  void erase(int r) {<br>    // Erase the r-th added point, of all the points that <br>    // have still not been erased.<br>    // Implement your erase here.<br>  }<br>  int size() {<br>    // Return how many points are still in the DS<br>  }<br>  pair&lt;int, int&gt; query() {<br>    // find two points p_i, p_j in the DS (not necessarily distinct),<br>    // such that the dot product of these two &lt;p_i, p_j&gt; (i &lt;= j) <br>    // the smallest among all. Return (i, j).<br>    // If the DS is empty for now, return (0, 0).<br>    // Implement your query here.<br>    // If there are multiple (i, j) satisfying the condition, output the lexicographically smallest pair.<br><br>  }<br>};<br><br>int main() {<br>  const int lim = 1E9;<br>  int q; cin &gt;&gt; q;<br>  for (int k = 0; k &lt; q; ++k) {<br>    unsigned state;<br>    cin &gt;&gt; state;<br>    string s;<br>    cin &gt;&gt; s;<br>    DataStructure ds;<br>    Magic magic(state);<br>    for (char c: s) {<br>      if (c == &apos;a&apos;) {<br>        // add one point<br>        int x = magic.retrieve(-lim, lim);<br>        int y = magic.retrieve(-lim, lim);<br>        ds.add(x, y);<br>      } else if (c == &apos;e&apos;) {<br>        // select the lucky point<br>        unsigned pos = magic.retrieve(1, ds.size());<br>        ds.erase(pos);<br>      } else if (c == &apos;q&apos;) {<br>        // query global minimum<br>        auto best = ds.query();<br>        magic.submit(best.first);<br>        magic.submit(best.second);<br>      }<br>    }<br>    cout &lt;&lt; magic.retrieveAns() &lt;&lt; endl;<br>  }<br>}<br></pre>","type":"description","format":"html"},{"title":"Input","content":"The input format is a little different from traditional. Instead of giving a large file of input, the input is produced by the program above in a protocol. Thus reading the code and getting what it&apos;s doing is a fundamental step to solve this problem. The code is provided only in C++, but you should be easily converted into other languages.<br><br>As you probably have seen, the program implements a protocol to generate the input data, based on some seeds (or input of input, if you like). The program reads from standard input: in the first line an integer $t$ ($1 \\le t \\le 20$), which is the number of test cases; then $t$ cases, each in two lines: first the integer state, which is between $10$ and $10^7$, inclusive; then follows a non-empty string of &quot;aeq&quot; of length no greater than $10^5$. &quot;a&quot; means add, &quot;e&quot; means erase and &quot;q&quot; means query. You would always find something to erase, i.e., we guarantee we will not try to erase from an empty data structure.<br>","type":"input_format","format":"html"},{"title":"Output","content":"Follow the practice of the given code for the output.<br><br>Here are some hints for the sample below.<br><br>Dot product of two points $p$ and $q$, is here, defined as the dot product from $0$ to $p$ and $0$ to $q$. Specifically, if $p=(a, b)$, $q=(c, d)$, dot product of $p$ and $q$ is $ac+bd$.<br><br>For sample input one, the queries are:<br><br>- Query: return $(0, 0)$.<br>- Add 1st point: $(518204527, -960426430)$.<br>- Query: return $(1, 1)$.<br><br>The answer is $20190812 \\cdot 1 + 1 = 20190813$.<br><br>For sample input two, the modifications and queries are:<br><br>- Add 1st point: $(-258558241, -773369213)$.<br>- Query: return $(1, 1)$.<br>- Add 2nd point: $(150662440, -65439273)$.<br>- Query: return $(1, 2)$.<br>- Add 3rd point: $(-888171126, -337111254)$.<br>- Erase 3rd point added among all still alive, so 3rd was erased.<br>- Query: return $(1, 2)$.<br>- Add 4th point: $(-470261300, 657949534)$.<br>- Add 5th point: $(-592507383, 366158932)$.<br>- Add 6th point: $(635425367, 329355360)$.<br>- Query: return $(1, 6)$.<br>- Add 7th point: $(900114299, 534416578)$.<br>- Erase 5th point added among all still alive, so 6th was erased.<br>- Query: return $(1, 7)$.<br>- Erase 2nd point added among all still alive, so 2nd was erased.<br>- Query: return $(1, 7)$.<br><br>Sample input three decodes to be as follows:<br><br>- Add 1st point: $(-457246811, -252726229)$.<br>- Add 2nd point: $(-815357226, 987160210)$.<br>- Add 3rd point: $(689370621, -861950583)$.<br>- Add 4th point: $(-850699215, -38670848)$.<br>- Add 5th point: $(187488045, -980321149)$.<br>- Add 6th point: $(217752313, -264046720)$.<br>- Query: return $(2, 3)$.<br>- Erase 2nd point added among all still alive, so 2nd was erased.<br>- Query: return $(3, 4)$.<br>- Erase 3rd point added among all still alive, so 4th was erased.<br>- Query: return $(1, 3)$.<br>- Erase 1st point added among all still alive, so 1st was erased.<br>- Query: return $(6, 6)$.<br>- Erase 3rd point added among all still alive, so 6th was erased.<br>- Query: return $(3, 5)$.<br>- Erase 1st point added among all still alive, so 3rd was erased.<br>- Query: return $(5, 5)$.<br>- Erase 1st point added among all still alive, so 5th was erased.<br>- Query: return $(0, 0)$.","type":"output_format","format":"html"},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">3\n42\nqaq\n84\naqaqaeqaaaqaeqeq\n9102\naaaaaaqeqeqeqeqeqeq</div></pre>","type":"example","format":"html"},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">20190813\n2668638611\n549902096</div></pre>","type":"example","format":"html"},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+7&amp;source=1&amp;searchmode=source\"> 2019 Multi-University Training Contest 7 </a> ","type":"source","format":"html"}]}