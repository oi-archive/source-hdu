{"title":"Keeps Going and Going and ...","time_limit":10000,"memory_limit":32,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=1475","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=1475&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=1475","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=1475"},"statement":[{"title":"Problem Description","content":"Lazy functional languages like Haskell and Miranda support features that are not found in other programming languages, including infinite lists. Consider the following simple (and useful) recursive declaration: <br>letrec<br>&#xA0;count n = cons n (count (n+1))<br>in<br>&#xA0;count 0<br><br>The function cons constructs lists, so the above declaration creates the following structure: <br><br>cons 0 (count 1)<br>= cons 0 (cons 1 (count 2))<br>= cons 0 (cons 1 (cons 2 ...))<br>= [0,1,2,...]<br><br>Lazy languages can do this because they only evaluate expressions that are actually used. If a program creates an infinite list and only looks at items 2 and 3 in it, the values in positions 0 and 1 are never evaluated and the list structure is only evaluated so far as the fourth node. <br><br><br>It is also possible to use more than one function to build an infinite list. Here is a declaration that creates the list [&quot;even&quot;,&quot;odd&quot;,&quot;even&quot;,...]: <br><br>letrec<br>&#xA0;even = cons &quot;even&quot; odd<br>&#xA0;odd = cons &quot;odd&quot; even<br>in<br>&#xA0;even<br><br>There are also functions that manipulate infinite lists. The functions take and drop can be used to remove elements from the start of the list, returning the (removed) front elements or the remainder of the list, respectively. Another useful function is zip, which combines two lists like the slider on a zipper combines the teeth. For example, <br><br>zip (count 0) (count 10) = [0,10,1,11,2,12,...]<br><br>Your task is to implement a subset of this functionality. <br><br><br>This problem contains multiple test cases!<br><br>The first line of a multiple input is an integer N, then a blank line followed by N input blocks. Each input block is in the format indicated in the problem description. There is a blank line between input blocks.<br><br>The output format consists of N output blocks. There is a blank line between output blocks.<br>","type":"description","format":"html","require":["katex"]},{"title":"Input","content":"The first line of input consists of two positive integers, n and m. n is the number of declarations to follow and m is the number of test cases. <br><br>Each declaration takes the form name = expr. There are two forms for expr : zip name1 name2 and x0 x1 ... xi name3. In the first case, name is the result of zipping name1 and name2 together. The other case defines the first i + 1 non-negative integers in the list name (where i is at least 0) and name3 is the name of the list that continues it (mandatory--all lists will be infinite). <br><br>The test cases take the form name s e, where s and e are non-negative integers, s &lt;= e and e - s &lt; 250. <br><br>No line of input will be longer than 80 characters. Names consist of a single capital letter. <br>","type":"input_format","format":"html","require":["katex"]},{"title":"Output","content":"For each test case, print the integers in positions s to e of the list name. List elements are numbered starting with 0. <br>","type":"output_format","format":"html","require":["katex"]},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">5 3\nS = 4 3 2 1 A\nO = 1 O\nE = 0 E\nA = zip E O\nZ = zip Z S\nA 43455436 43455438\nS 2 5\nZ 1 10</div></pre>","type":"example","format":"html","require":["katex"]},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">0 1 0\n2 1 0 1\n4 4 3 4 2 3 1 4 0 2</div></pre>","type":"example","format":"html","require":["katex"]},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=ACM%CA%EE%C6%DA%BC%AF%D1%B5%B6%D3%C1%B7%CF%B0%C8%FC%A3%A8%CA%AE%A3%A9&amp;source=1&amp;searchmode=source\"> ACM&#x6691;&#x671F;&#x96C6;&#x8BAD;&#x961F;&#x7EC3;&#x4E60;&#x8D5B;&#xFF08;&#x5341;&#xFF09; </a> ","type":"source","format":"html","require":["katex"]}]}