{"title":"Lambda Calculus","time_limit":1000,"memory_limit":64,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=5987","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=5987&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=5987","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=5987"},"statement":[{"title":"Problem Description","content":"The <b>lambda calculus</b> is a simple language that is often used to study the theory of programming languages. This language only consists of variable references, functions that take a single argument, and applications of functions.<br>The lambda calculus consists of a language of <b>lambda terms</b>. The syntax of the lambda calculus defines that all valid lambda terms can be built by applying the following three rules:<br>1. a <b>variable</b> x, which is a nonempty string other than lambda, is itself a lambda term;<br>2. if t is a valid lambda term, and x is a variable, then (lambda (x) t) is a lambda term (called a <b>lambda abstraction</b>), here x has at least one occurrence in t;<br>3. if t and s are lambda terms, then (t s) is a lambda term (called an <b>application</b>).<br>Nothing else is a lambda term. Thus a lambda term is valid if and only if it can be obtained by repeated application of these three rules. Note that the parentheses in the second and the third rule can NOT be omitted.<br>A <b>lambda abstraction</b> (lambda (x) t) is a definition of an anonymous function that is capable of taking a single input x and substituting it into the term t. The abstraction <b>binds</b> the variable x in term t, so we call it a <b>lambda binding</b> of variable x.<br>An <b>application</b> (t s) represents the application of a function t to an input s, that is, it represents the act of calling<br>function t on input s to produce t(s).<br>To see how this works, consider the lambda calculus extended with arithmetic operators. In that language, a lambda abstraction (lambda (x) x + 5), in which x is bound, defines a function f(x) = x + 5. And an application ((lambda (x) x + 5) 3) applies function f(x) = x + 5 to input 3 and produces f(3) = 3 + 5 = 8.<br>We say that a variable <b>occurs free</b> in an lambda term t if it has some occurrence in t that is not inside some lambda binding of the same variable. For example,<br>     $\\bullet$ x occurs free in x;<br>     $\\bullet$ x does not occur free in y;<br>     $\\bullet$ x does not occur free in (lambda (x) (x y));<br>     $\\bullet$ x occurs free in (lambda (y) (x y));<br>     $\\bullet$ x occurs free in ((lambda (x) x) (x y)), which is an application that produces (x y) in which x occurs free;<br>     $\\bullet$ x occurs free in (lambda (y) (lambda (z) (x (y z)))).<br>Now you are given a lambda term t, you need to find all distinct variables that occur free in t.<br>","type":"description","format":"html"},{"title":"Input","content":"The first line of the input contains a positive integer T denoting the number of test cases. Then T lines follow, each line contains a nonempty string denoting a lambda term.<br>Each variable in the the lambda terms contains only latin letters and the hyphen, and is no longer than 20 characters.<br>It is guaranteed that all lambda terms in the input are valid, and the total length of all lambda terms will not exceed 107 .<br>There might be some extra spaces in the input as long as they do not cause any misunderstanding.","type":"input_format","format":"html"},{"title":"Output","content":"For each test case, output first the case number and then all distinct variables that occur free in the lambda term in a single line. These variables should be printed in lexicographic order, and there should be a single space between<br>each two adjacent variables. There should be a space after the colon in each test case.<br>","type":"output_format","format":"html"},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">6\nx\ny\n(lambda (x) (x y))\n(lambda (y) (x y))\n( (lambda (x) x) (x y) )\n( lambda (y) ( lambda (z) (x (y z)) ) )</div></pre>","type":"example","format":"html"},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">Case #1: x\nCase #2: y\nCase #3: y\nCase #4: x\nCase #5: x y\nCase #6: x\n<div style=\"font-family:Times New Roman;font-size:14px;background-color:F4FBFF;border:#B7CBFF 1px dashed;padding:6px\"><div style=\"font-family:Arial;font-weight:bold;color:#7CA9ED;border-bottom:#B7CBFF 1px dashed\"><i>Hint</i></div>\nThe free variables of a term are those variables not bound by a lambda abstraction. The set of free variables of\nan expression is defined inductively:\n1. The free variables of x are just x;\n2. The set of free variables of (lambda (x) t) is the set of free variables of t, but with x removed;\n3. The set of free variables of (t s) is the union\nWe can define it with the context-free grammar:\n                                                      LcExp ::= Variable\n                                                                  ::= (lambda (Variable) LcExp)\n                                                                  ::= (LcExp LcExp)\nwhere a variable is any string other than lambda.\n</div><i style=\"font-size:1px\"> </i></div></pre>","type":"example","format":"html"},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=2016ACM%2FICPC%D1%C7%D6%DE%C7%F8%C7%E0%B5%BA%D5%BE-%D6%D8%CF%D6%C8%FC%A3%A8%B8%D0%D0%BB%D6%D0%B9%FA%CA%AF%D3%CD%B4%F3%D1%A7%A3%A9&amp;source=1&amp;searchmode=source\"> 2016ACM/ICPC&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xD7A;&#x57E;-&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#x43B;&#xFFFD;&#x439;&#xFFFD;&#x2AF;&#xFFFD;&#x374;&#xFFFD;&#x467;&#xFFFD;&#xFFFD; </a> ","type":"source","format":"html"}]}