{"title":"String-Matching Automata","time_limit":1000,"memory_limit":32,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=3407","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=3407&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=3407","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=3407"},"statement":[{"title":"Problem Description","content":"The finite state automaton (FSA) is an important model of behavioral investigations in computer science, linguistics and many other areas. A FSA can be typically modeled as a string pattern recognizer described by a quintuple &lt;&#xFFFD;&#xFFFD;, S, s0, &#xFFFD;&#xFFFD;, F&gt;, where:<br><br>    &#xFFFD;&#xFFFD; is the input alphabet (a finite nonempty set of symbols).<br>    S is a finite nonempty set of states.<br>    s0 is an element in S designated as the initial state.<br>    &#xFFFD;&#xFFFD; is a function &#xFFFD;&#xFFFD;: S &#xFFFD;&#xFFFD; &#xFFFD;&#xFFFD; &#xFFFD;&#xFFFD; S known as the transition function.<br>    F is a (possibly empty) subset of S whose elements are designated as the final states.<br><br>An FSA with the above description operates as follows:<br><br>    At the beginning, the automaton starts in the initial state s0.<br>The automaton continuously reads symbols from its input, one symbol at a time, and transits between states according to the transition function &#xFFFD;&#xFFFD;. To be specific, let s be the current state and w the symbol just read, the automaton moves to the state given by &#xFFFD;&#xFFFD;(s, w).<br>    When the automaton reaches the end of the input, if the current state belongs to F, the string consisting sequentially of the symbols read by the automaton is declared accepted, otherwise it is declared rejected.<br><br>Just as the name implies, a string-matching automaton is a FSA that is used for string matching and is very efficient: they examine each character exactly once, taking constant time per text character. The matching time used (after the automaton is built) is therefore &#xFFFD;&#xFFFD;(n). However, the time to build the automaton can be large.<br><br>Precisely, there is a string-matching automaton for every pattern P that you search for in a given text string T. For a given pattern of length m, the corresponding automaton has (m + 1) states {q0, q1, &#xFFFD;&#xFFFD;, qm}: q0 is the start state, qm is the only final state, and for each i in {0, 1, &#xFFFD;&#xFFFD;, m}, if the automaton reaches state qi, it means the length of the longest prefix of P that is also a suffix of the input string is i. When we reaches state qm, it means P is a suffix of the currently input string, which suggest we find an occurrence of P.<br><br>The following graph shows a string-matching automaton for the pattern &#xFFFD;&#xFFFD;ababaca&#xFFFD;&#xFFFD;, and illustrates how the automaton works given an input string &#xFFFD;&#xFFFD;abababacaba&#xFFFD;&#xFFFD;.<br><br><br><center><img style=\"max-width:100%;\" src=\"../../../data/images/3407-1.png\"></center><br>Apparently, the matching process using string-matching automata is quite simple (also efficient). However, building the automaton efficiently seems to be tough, and that&#xFFFD;&#xFFFD;s your task in this problem.","type":"description","format":"html"},{"title":"Input","content":"Several lines, each line has one pattern consist of only lowercase alphabetic characters. The length of the longest pattern is 10000. The input ends with a separate line of &#xFFFD;&#xFFFD;0&#xFFFD;&#xFFFD;. ","type":"input_format","format":"html"},{"title":"Output","content":"For each pattern, output should contain (m + 1) lines(m is the length of the pattern). The nth line describes how the automaton changes its state from state (n-1) after reading a character. It starts with the state number (n &#xFFFD;C 1), and then 26 state numbers follow. The 1st state number p1 indicates that when the automaton is in state (n-1), it will transit to state p1 after reading a character &#xFFFD;&#xFFFD;a&#xFFFD;&#xFFFD;. The 2nd state number p2 indicates that when the automaton is in state (n-1), it will transit to state p2 after reading a character &#xFFFD;&#xFFFD;b&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD; And so on.","type":"output_format","format":"html"},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">ababaca\n0</div></pre>","type":"example","format":"html"},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n2 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n3 1 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n4 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n5 1 4 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n6 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n7 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</div></pre>","type":"example","format":"html"},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=2010+National+Programming+Invitational+Contest+Host+by+ZSTU+&amp;source=1&amp;searchmode=source\"> 2010 National Programming Invitational Contest Host by ZSTU  </a> ","type":"source","format":"html"}]}