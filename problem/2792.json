{"title":"Tree Insertions","time_limit":1000,"memory_limit":32,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=2792","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=2792&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=2792","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=2792"},"statement":[{"title":"Problem Description","content":"All modern banks employ information systems to process their data. The amount of data is enormous. Imagine all the transactions, payments, e-banking, web services, etc. Therefore, advanced data structures must be used to store the data and allow to access them very quickly.<br><br>A Binary Search Tree (BST) is one example of such a data structure It holds a collection of values with some comparison operation that provides linear ordering on these values.<br><br>BST consists of nodes, each of them contains one value and has at most two subnodes: left and right (BST is a binary tree). The left subtree always contains only values strictly less than the node value, the right subtree only values greater than or equal to the node value.<br><br>As a consequence, values may easily be looked up by traversing the tree recursively. We begin with the root node and compare its value with the value we are searching for. Depending on the result, we descend either into the left or into the right subtree, but we never need to walk through both.<br><br>If we want to insert values to an existing tree, the procedure is also simple. The first value (when the tree is empty) is always put as the root. If the tree already exists, we start with the root node and traverse the tree recursively, as in the case of searching. When the traversal leads us to a missing subnode, we create a new leaf node at that position and assign it the new value.<br><br>The figures below show the tree after subsequently adding the following sequence of numbers: 3, 4, 3, 5, 4, 1, and 2.<br><br><center><img style=\"max-width:100%;\" src=\"../../../data/images/C201-1009-1.jpg\"></center><br><br>You may notice that different permutations of the same numbers will often result in the same BST. For example, the tree from the fifth figure above may be constructed by three different input sequences:<br><br># 3, 4, 3, 5, 4<br># 3, 4, 5, 4, 3<br># 3, 4, 5, 3, 4<br><br>Interesting, isn&apos;t it? Your task is to compute how many different permutations are there that will result into the same BST. ","type":"description","format":"html","require":["katex"]},{"title":"Input","content":"The input will consist of several trees, each of them specified on two lines. The first line contains a single integer N (1 &#x2264; N &#x2264; 100), the number of values in the tree. The second line contains N values separated by a space. These values, if inserted in the given order, form a BST to be examined. All values will be between 0 and 1000.<br><br>The last tree is followed by a line containing a single zero.","type":"input_format","format":"html","require":["katex"]},{"title":"Output","content":"For each tree, output the total number of different permutations that would generate the same Binary Search Tree. As you may notice in the Sample Output, this number may exceed 2^32.","type":"output_format","format":"html","require":["katex"]},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">5\n3 4 3 5 4\n7\n3 4 3 5 4 1 2\n31\n16 8 24 4 12 20 28 2 6 10 14 18 22 26 30 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31\n0</div></pre>","type":"example","format":"html","require":["katex"]},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">3\n45\n74836825861835980800000</div></pre>","type":"example","format":"html","require":["katex"]},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=CTU+Open+2008&amp;source=1&amp;searchmode=source\"> CTU Open 2008 </a> ","type":"source","format":"html","require":["katex"]}]}