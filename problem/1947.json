{"title":"Lazy Evaluation","time_limit":1000,"memory_limit":32,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=1947","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=1947&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=1947","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=1947"},"statement":[{"title":"Problem Description","content":"Most of the programming languages used in practice perform strictevaluation.<br>When a function is called, the expressions passed in the function arguments (for instance a + b in f (a + b, 3)) are evaluated first,and the resulting values are passed to the function. <br>However, this is not the only way how expressions can be evaluated, and in fact, even such a mainstream language as C++ is sometimes performing lazy evaluation: the operators &amp;&amp; and jj evaluate only those arguments that are needed to determine the value of the expression. <br>Pal Christian is now working on a comparative study of the performance of the lazy and strict evaluation. Pal wants to evaluate in both ways a set of expressions that follow this simpli\u0002ed syntax:<br>&#xFF0D;&#xFF0D;an expression is either a constant, a name, or a function call<br>&#xFF0D;&#xFF0D;a constant is a signed 32-bit integer; for example, 3, 0, -2, 123 are constants;<br>&#xFF0D;&#xFF0D;a name is a name of a built-in or user-de\u0002ned function, for example, f , or add are names; names are words containing up to 32 lowercase letters from the English alphabet; <br>&#xFF0D;&#xFF0D;function call has the form: ( f unction arg1 . . . argN ), where f unction is an expression that evaluates to some function of N arguments, and arg1 . . . argN are expressions that evaluate to arguments passed to the function. For example, ( f 3 5 ) , or ( add 2 ( add 1 2 )) are valid function calls.<br>Expressions are evaluated according to the following simple rules:<br>&#xFF0D;&#xFF0D;constants evaluate to themselves<br>&#xFF0D;&#xFF0D;names evaluate to the functions they denote<br>&#xFF0D;&#xFF0D;function calls:<br>in lazy evaluation: the first expression is evaluated first to obtain a function, whose function body, with formal parameters substituted for the expressions provided as the arguments, is evaluated; however, whenever some argument gets evaluated while evaluating the  function body, the resulting value will replace all occurences of the same parameter in that function body. In other words, the expression passed in the argument is never evaluated more than once. <br>in strict evaluation: all expressions are evaluated first: the first expression  should evaluate to a function, the remaining to values that are used as function arguments; the result is the result of evaluating the corresponding function body, where all occurences of formal parameters are replaced by the values obtained by evaluating the arguments.<br><br>The following built-in functions are available: add x y - sum of the constants x and y, sub x y - returns the value x-y, mult x y - product of x and y, div x y - integer division, and rem x y - remainder (same semantics as &apos;/&apos; and &apos;%&apos; in C, C++ or Java), true x y - always returns x, f alse x y - always returns y , eq x y - returns true if x and y is the same constant, otherwise returns f alse, gt x y - returns true if x is greater than y, otherwise returns f alse.<br><br>User-defined functions are defined using the following syntax:<br>f unction name arg1 . . . argN = body, where arg1 . . . argN are distinct words (up to 32 English lowercase letters), denoting the formal parameters of the function, and the body is an expression. The formal parameters can occur in the body of the function in place of constants or names. The function name and the formal parameters are separated by a single space. There is one space on both sides of the &quot;=&quot;. Functions with zero (no)  rguments are legal. Note that the formal parameters can overshadow the function names (i.e. op in definition of not in sample input overshadows the function name op), but each function must have a unique name. ","type":"description","format":"html"},{"title":"Input","content":"The first part of the input contains (less than 1000) lines with one function de\u0002nition each, followed by a single empty line. Forward references (that is, referring to functions de\u0002ned later in the input) and recursion are legal. The second part of the input contains less than 1000 test expressions. Each test expression is an expresion occupying a single line. Function names and the arguments are always separated by a single space, but there are no extra spaces around parentheses (see sample input). There is an empty line after the last expression. Expressions are to be evaluated by both the lazy and the strict evaluation. You can assume that all function definitions and expressions are syntactically correct, and that the arithmetic built-in functions (add, sub,<br>mult, div, rem, eq, gt) will always be called with integers only, and no division by 0 occurs. Over\u0003ows outside the 32-bit integer range are legal and do not require any special treatment (just use the value produced by C, C++, or Java operators +, -, *, /, or %). In strict evaluation, built-in functions evaluate all their arguments too. In lazy evaluation, arithmetic built-in functions always evaluate all their arguments. All lines on the input contain no more than 255 characters including spaces. ","type":"input_format","format":"html"},{"title":"Output","content":"The program should produce a table in exactly the following format:<br><br>    operator   lazy_evaluation          strict_evaluation<br>    add          addlazy                    addstrict<br>    sub          sublazy                     substrict<br>    mult         multlazy                   multstrict<br>    div           divlazy                     divstrict<br>    rem          remlazy                   remstrict<br><br>where each <img style=\"max-width:100%;\" src=\"data/images/1947-1.gif\"> is an integer - how many times op has been executed in lazy evaluation of all expressions, and <img style=\"max-width:100%;\" src=\"data/images/1947-2.gif\"> is the number of evaluations of <img style=\"max-width:100%;\" src=\"data/images/1947-3.gif\"> in strict evaluation. Spaces can occur arbitrarily. If the evaluation of a test expression does not terminate after a total of 2345 function evaluations , you can assume that it is in an in\u0002nite loop, the program should skip that expression, and do not count it into the totals (omit counting operations both in lazy and strict evaluation of this expression). ","type":"output_format","format":"html"},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">if cond truepart elsepart = (cond truepart elsepart)\nfact x = (facta x 1)\nfacta x a = (if (eq x 0) a (facta (sub x 1) (mult a x)))\nand x y = (x y false)\nident x = x\ntwo = 2\nop op x = ((if (eq op 1) add sub) op x)\nnot op = (op false true)\nsum n = (suma n 0)\nsuma n a = (((gt n 1) suma false) (sub n 1) (add a n))\n(true (add 1 2) (mult 1 2))\n5\ntrue\n(and (gt (op (sub 2 1) 1) 5) (eq (two) (op 1 1)))\n(false (sub 1 2) (sum 4))\n((eq (true 1 2) (false 2 1)) (add 1 2) (sub 1 2))\n(fact 3)</div></pre>","type":"example","format":"html"},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">operator lazy_evaluation strict_evaluation\nadd                 7                     8\nsub                 4                     7\nmult                0                     1\ndiv                  0                     0\nrem                 0                     0</div></pre>","type":"example","format":"html"},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=NM2004&amp;source=1&amp;searchmode=source\"> NM2004 </a> ","type":"source","format":"html"}]}