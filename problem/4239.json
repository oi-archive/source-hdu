{"title":"Decoding EDSAC Data","time_limit":1000,"memory_limit":32,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=4239","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=4239&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=4239","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=4239"},"statement":[{"title":"Problem Description","content":"The world&apos;s first full-scale, stored-program, electronic, digital computer was the EDSAC (Electronic Delay Storage Automatic Calculator). The EDSAC had an accumulator-based instruction set, operating on 17-bit words(and 35-bit double words), and used a 5-bit teletypewriter code for input and output.<br><br>The EDSAC was programmed using a very simple assembly language: a single letter opcode followed by an unsigned decimal address, followed by the the letter &quot;F&quot;(for full word) or &quot;D&quot;(for double word). For example, the instruction &quot;A 128 F&quot; would mean &quot;add the full word at location 128 to the accumulator&quot;, and would be assembled into the 17-bit binary value, 11100000100000000, consisting of a 5-bit opcode(11100=&quot;add&quot;), an 11-bit operand (00010000000 = 128), and a single 0 bit denoting a full word operation(a 1 bit would indicate a double word operation).<br><br>Although arithmetic on the EDSAC was fixed point two&apos;s complement binary, it was not mere intger arithmetic (as is common with modern machines). The EDSAC hardware assumed a binary point between the lrftmost bit and its immediate successor. Thus the hardware could handle only values in the range -1.0 &lt;= x &lt; 1.0 . For example:<br><center><img style=\"max-width:100%;\" src=\"../../data/images/C397-1004-1.jpg\"></center><br>As you can see, the largest possible positive value was:<br><center><img style=\"max-width:100%;\" src=\"../../data/images/C397-1004-2.jpg\"></center><br>and the smallest possible positive value was:<br><center><img style=\"max-width:100%;\" src=\"../../data/images/C397-1004-3.jpg\"></center><br>(This also happens to be the increment between successive values on the EDSAC).<br>By a curious coincidence(or an elegant design decision), the opcode for the add operation(11100) was the same as the teleprinter code for the letter&quot;A&quot;. The opcode for subtract was the same as the teleprinter code for &quot;S&quot;(01100), and so on. This simplified the programming for the assembler (which, incidentally, was a mere 31 instructions long). The EDSAC teleprinter alphabet was &quot;PQWERTYUIOJ#SZK*?F@D!HNM&amp;LXGABCV&quot;(with &quot;P&quot;=00000, &quot;Q&quot;=00001, and so on, up to &quot;V&quot;=11111)<br>UNfortunately, the EDSAC assembler had no special directives for data values. On the other hand, there was no reason that ordinary instructions couldn&apos;t be used for this , thus, an EDSAC programmer desiring to reserve space for the constant 3/4(represented as 01100000000000000) would use the instruction &quot;S O F&quot; and for 1/3(which is approximately represented as 00101010101010101)&quot;T 682 D&quot;, and so on.<br>Your job is to write a program that will translate EDSAC instructions  into the appropriate decimal fractions.<br>","type":"description","format":"html"},{"title":"Input","content":"The first line of input contains a single integer P ( 1 &lt;= P &lt;= 1000 ) which is the number of data sets that follow. Each data set is a single line that contains N (the dataset number), followed by a space, followed by an EDSAC instruction of the form:  c&#x25A1;d&#x25A1;s , where c is a single character in the EDSAC alphabet, d is an unsigned decimal number (0 &lt;= d &lt; 2^11), and s is either a&apos;D&apos;or&apos;F&apos;.<br><div style=\"font-family:Times New Roman;font-size:14px;background-color:F4FBFF;border:#B7CBFF 1px dashed;padding:6px\"><div style=\"font-family:Arial;font-weight:bold;color:#7CA9ED;border-bottom:#B7CBFF 1px dashed\"><i>Hint</i></div>Note:&#x25A1; represents a single space.</div>","type":"input_format","format":"html"},{"title":"Output","content":"For each data set there is one line of output. It contains the data set number (N) followed by a single space, followed by the exact decimal fraction represented by the by the EDSAC instruction, including a minus sign (for negative values). The format for the decimal fraction  is: sb.ddd..., where s is an optional minus sign, b is either a 1 or 0, and d is any decimal digit (0-9). There must be at least 1 and at most 16 digits after the decimal point. Trailing zeros in the fraction must be suppressed. ","type":"output_format","format":"html"},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">13\n1 P 0 F\n2 I 0 F\n3 &amp; 0 F\n4 ? 0 F\n5 Q 1228 D\n6 P 0 D\n7 V 2047 D\n8 * 2047 D\n9 ? 0 D\n10 P 256 F\n11 V 1536 F\n12 T 682 D\n13 T 54 F </div></pre>","type":"example","format":"html"},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">1 0.0\n2 0.5\n3 -0.5\n4 -1.0\n5 0.0999908447265625\n6 0.0000152587890625\n7 -0.0000152587890625\n8 0.9999847412109375\n9 -0.9999847412109375\n10 0.0078125\n11 -0.015625\n12 0.3333282470703125\n13 0.31414794921875</div></pre>","type":"example","format":"html"},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=2011+Greater+New+York+Regional+&amp;source=1&amp;searchmode=source\"> 2011 Greater New York Regional  </a> ","type":"source","format":"html"}]}