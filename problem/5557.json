{"title":"Matching Compressed String","time_limit":6000,"memory_limit":64,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=5557","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=5557&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=5557","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=5557"},"statement":[{"title":"Problem Description","content":"You are given a long string and looking for certain patterns in the string.<br>The string contains only lowercase letters $(a-z)$, and it is represented in a compressed format. Denoting $S_1, S_2, ...$ as compressed strings, another compressed string $S$ is defined recursively in one of the following ways:<br><br>&#xA0;&#xA0;$\\cdot$ $S$ can be any string consisting of only lowercase letters $(a-z)$.<br>&#xA0;&#xA0;$\\cdot$ $S$ can be generated by repeating another string for any times. Specifically, $S$ is represented as &#xFFFD;&#xFFFD;<b>R(S1)</b>&#xFFFD;&#xFFFD;, which means that the content of $S_1$ is repeated $R$ times.<br>&#xA0;&#xA0;$\\cdot$ $S$ can also be the concatenation of other strings. Specifically, $S$ is represented as &#xFFFD;&#xFFFD;$S_1,S_2...S_L$&#xFFFD;&#xFFFD;, which means $S$ is the concatenation of $S_1, S_2, ..., S_L$.<br>&#xA0;&#xA0;$\\cdot$An empty string (&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;) is also a valid representation.<br><br>Formally, the Backus&#xFFFD;CNaur Form (BNF) specification of the syntax is<br><br>&lt;compressed&gt; ::= &#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD; | &lt;lowercase-letter&gt; | &lt;compressed&gt; &lt;compressed&gt; | &lt;number&gt; &#xFFFD;&#xFFFD;(&#xFFFD;&#xFFFD; &lt;compressed&gt; &#xFFFD;&#xFFFD;)&#xFFFD;&#xFFFD;<br><br>For example, the string &#xFFFD;&#xFFFD;baaabbaaab&#xFFFD;&#xFFFD; can be compressed as &#xFFFD;&#xFFFD;b3(a)2(b)3(a)b&#xFFFD;&#xFFFD;. It can also be compressed as &#xFFFD;&#xFFFD;2(b3(a)b)&#xFFFD;&#xFFFD;.<br><br>On the other hand, you find deterministic finite automaton (DFA) as powerful way to describe the patterns you are looking for. A DFA contains a finite set of states $Q$ and a finite set of input symbols called the alphabet &#xFFFD;&#xFFFD;. Initially, the DFA is positioned at the start state $q_0&#xFFFD;&#xFFFD;Q$. Given the transition function $&#xFFFD;&#xFFFD;(q,a)$ and an input symbol $a$, the DFA transit to state $&#xFFFD;&#xFFFD;(q,a)$ if its current state is $q$.<br><br>Let $w=a_1 a_2...a_n$ be a string over the alphabet &#xFFFD;&#xFFFD;. According to the above definition, the DFA transits through the following sequence of states.<br>$$q_0,q_1=&#xFFFD;&#xFFFD;(q_0,a_1 ),q_2=&#xFFFD;&#xFFFD;(q_1,a_2 ),&#xFFFD;&#xFFFD;,q_n=&#xFFFD;&#xFFFD;(q_(n-1),a_n )$$<br>The DFA also contains a set of accept states $F\\subseteq Q$. If the last state $q_n$ is an accept state, we say that the DFA accepts the string $w$. The set of accepted strings is referred as the language that the DFA represents.<br><br>Now you are given a compressed string $S$ and a DFA $A$. You want to know if $A$ accepts the decompressed content of $S$. <br>","type":"description","format":"html"},{"title":"Input","content":"The first line of input contains a number T indicating the number of test cases ($T&#xFFFD;&#xFFFD;200$).<br><br>The first line of each test case contains a non-empty compressed string $S$, as described above. The length of $S$ is not greater than 10000, and $0&#xFFFD;&#xFFFD;R&#xFFFD;&#xFFFD;10^9$. It is guaranteed that the representation of $S$ is valid.<br><br>The description of the DFA follows.<br><br>The first line of the description contains three integers $N$, $M$, and $K$, indicating the number of states, the number of rules describing the transition function, and the number of accept states ($1&#xFFFD;&#xFFFD;K&#xFFFD;&#xFFFD;N&#xFFFD;&#xFFFD;1000,0&#xFFFD;&#xFFFD;M&#xFFFD;&#xFFFD;26N$). The states are numbered from 0 to $N-1$. The start state is always 0.<br><br>The second line contains $K$ integers representing the accept states. All these numbers are distinct.<br><br>Each of the next $M$ lines consists of two states $p$ and $q$, and an input symbol $a$, which means that the DFA transits from $p$ to $q$ when it receives the symbol $a$. The symbol $a$ is always a lowercase letter. It is guaranteed that, given $p$ and $a$, the next state $q$ is unique.<br>","type":"input_format","format":"html"},{"title":"Output","content":"For each test case, output a single line consisting of &#xFFFD;&#xFFFD;<b>Case #X: Y</b>&#xFFFD;&#xFFFD;. $X$ is the test case number starting from 1. $Y$ is &#xFFFD;&#xFFFD;<b>Yes</b>&#xFFFD;&#xFFFD; if the DFA accepts the string, or &#xFFFD;&#xFFFD;<b>No</b>&#xFFFD;&#xFFFD; otherwise.","type":"output_format","format":"html"},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">3\n2(b3(a)b)\n2 3 1\n0\n0 1 b\n1 0 b\n1 1 a\nb3(a)2(b)3(a)b\n2 2 1\n1\n0 1 b\n1 0 a\nb3(a)2(b)3(a)b\n2 4 1\n0\n0 1 b\n0 1 a\n1 0 a\n1 0 b</div></pre>","type":"example","format":"html"},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">Case #1: Yes\nCase #2: No\nCase #3: Yes</div></pre>","type":"example","format":"html"},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=2015ACM%2FICPC%D1%C7%D6%DE%C7%F8%BA%CF%B7%CA%D5%BE-%D6%D8%CF%D6%C8%FC%A3%A8%B8%D0%D0%BB%D6%D0%BF%C6%B4%F3%A3%A9&amp;source=1&amp;searchmode=source\"> 2015ACM/ICPC&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#x3F7;&#xFFFD;&#x57E;-&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;&#x43B;&#xFFFD;&#x43F;&#x1B4;&#xFFFD; </a> ","type":"source","format":"html"}]}