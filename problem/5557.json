{"title":"Matching Compressed String","time_limit":6000,"memory_limit":64,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=5557","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=5557&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=5557","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=5557"},"statement":[{"title":"Problem Description","content":"You are given a long string and looking for certain patterns in the string.<br>The string contains only lowercase letters $(a-z)$, and it is represented in a compressed format. Denoting $S_1, S_2, ...$ as compressed strings, another compressed string $S$ is defined recursively in one of the following ways:<br><br>&#xA0;&#xA0;$\\cdot$ $S$ can be any string consisting of only lowercase letters $(a-z)$.<br>&#xA0;&#xA0;$\\cdot$ $S$ can be generated by repeating another string for any times. Specifically, $S$ is represented as &#x201C;<b>R(S1)</b>&#x201D;, which means that the content of $S_1$ is repeated $R$ times.<br>&#xA0;&#xA0;$\\cdot$ $S$ can also be the concatenation of other strings. Specifically, $S$ is represented as &#x201C;$S_1,S_2...S_L$&#x201D;, which means $S$ is the concatenation of $S_1, S_2, ..., S_L$.<br>&#xA0;&#xA0;$\\cdot$An empty string (&#x201C;&#x201D;) is also a valid representation.<br><br>Formally, the Backus&#x2013;Naur Form (BNF) specification of the syntax is<br><br>&lt;compressed&gt; ::= &#x201C;&#x201D; | &lt;lowercase-letter&gt; | &lt;compressed&gt; &lt;compressed&gt; | &lt;number&gt; &#x201C;(&#x201D; &lt;compressed&gt; &#x201C;)&#x201D;<br><br>For example, the string &#x201C;baaabbaaab&#x201D; can be compressed as &#x201C;b3(a)2(b)3(a)b&#x201D;. It can also be compressed as &#x201C;2(b3(a)b)&#x201D;.<br><br>On the other hand, you find deterministic finite automaton (DFA) as powerful way to describe the patterns you are looking for. A DFA contains a finite set of states $Q$ and a finite set of input symbols called the alphabet &#x3A3;. Initially, the DFA is positioned at the start state $q_0&#x2208;Q$. Given the transition function $&#x3B4;(q,a)$ and an input symbol $a$, the DFA transit to state $&#x3B4;(q,a)$ if its current state is $q$.<br><br>Let $w=a_1 a_2...a_n$ be a string over the alphabet &#x3A3;. According to the above definition, the DFA transits through the following sequence of states.<br>$$q_0,q_1=&#x3B4;(q_0,a_1 ),q_2=&#x3B4;(q_1,a_2 ),&#x2026;,q_n=&#x3B4;(q_(n-1),a_n )$$<br>The DFA also contains a set of accept states $F\\subseteq Q$. If the last state $q_n$ is an accept state, we say that the DFA accepts the string $w$. The set of accepted strings is referred as the language that the DFA represents.<br><br>Now you are given a compressed string $S$ and a DFA $A$. You want to know if $A$ accepts the decompressed content of $S$. <br>","type":"description","format":"html","require":["katex"]},{"title":"Input","content":"The first line of input contains a number T indicating the number of test cases ($T&#x2264;200$).<br><br>The first line of each test case contains a non-empty compressed string $S$, as described above. The length of $S$ is not greater than 10000, and $0&#x2264;R&#x2264;10^9$. It is guaranteed that the representation of $S$ is valid.<br><br>The description of the DFA follows.<br><br>The first line of the description contains three integers $N$, $M$, and $K$, indicating the number of states, the number of rules describing the transition function, and the number of accept states ($1&#x2264;K&#x2264;N&#x2264;1000,0&#x2264;M&#x2264;26N$). The states are numbered from 0 to $N-1$. The start state is always 0.<br><br>The second line contains $K$ integers representing the accept states. All these numbers are distinct.<br><br>Each of the next $M$ lines consists of two states $p$ and $q$, and an input symbol $a$, which means that the DFA transits from $p$ to $q$ when it receives the symbol $a$. The symbol $a$ is always a lowercase letter. It is guaranteed that, given $p$ and $a$, the next state $q$ is unique.<br>","type":"input_format","format":"html","require":["katex"]},{"title":"Output","content":"For each test case, output a single line consisting of &#x201C;<b>Case #X: Y</b>&#x201D;. $X$ is the test case number starting from 1. $Y$ is &#x201C;<b>Yes</b>&#x201D; if the DFA accepts the string, or &#x201C;<b>No</b>&#x201D; otherwise.","type":"output_format","format":"html","require":["katex"]},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">3\n2(b3(a)b)\n2 3 1\n0\n0 1 b\n1 0 b\n1 1 a\nb3(a)2(b)3(a)b\n2 2 1\n1\n0 1 b\n1 0 a\nb3(a)2(b)3(a)b\n2 4 1\n0\n0 1 b\n0 1 a\n1 0 a\n1 0 b</div></pre>","type":"example","format":"html","require":["katex"]},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">Case #1: Yes\nCase #2: No\nCase #3: Yes</div></pre>","type":"example","format":"html","require":["katex"]},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=2015ACM%2FICPC%D1%C7%D6%DE%C7%F8%BA%CF%B7%CA%D5%BE-%D6%D8%CF%D6%C8%FC%A3%A8%B8%D0%D0%BB%D6%D0%BF%C6%B4%F3%A3%A9&amp;source=1&amp;searchmode=source\"> 2015ACM/ICPC&#x4E9A;&#x6D32;&#x533A;&#x5408;&#x80A5;&#x7AD9;-&#x91CD;&#x73B0;&#x8D5B;&#xFF08;&#x611F;&#x8C22;&#x4E2D;&#x79D1;&#x5927;&#xFF09; </a> ","type":"source","format":"html","require":["katex"]}]}