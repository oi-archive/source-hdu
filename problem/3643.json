{"title":"Boolean String Expression","time_limit":1000,"memory_limit":32,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=3643","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=3643&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=3643","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=3643"},"statement":[{"title":"Problem Description","content":"Mike needs a bike and he decides to buy a second-hand one to save money. Luckily, he has found a second-hand goods BBS. However, there are so many messages there and it will be extremely boring for him to look through all those messages and figure out which one contains the information he needs. So he decides to write a program to do this.<br><br>The problem is: how to determine whether a message is about selling a bike. Mike decides to use a keyword-find-based algorithm. First choose some keywords and then the program checks whether a message contains these keywords or not. For example, he wants to find messages that contain &apos;bike&apos;&#xFFFD;&#xFFFD;and at the same time have &apos;sell&apos; or don&apos;t have &apos;buy&apos; (&quot;bike on sell&quot;, &quot;bike&quot;, &quot;sell bike and buy &#xFFFD;&#xFFFD;&quot;are all what he needs, but &quot;buy bike&quot; is not). Of course he wants his program can be used to handle things more than buying a bike.<br><br>As the string matching nature of the keyword-find-based algorithm, regular expression should be quite suitable here. But after a second thought, he throws it away: he even can&apos;t figure out what the corresponding regular expression is for a simple query &quot;don&apos;t have the word &apos;buy&apos;&quot;.<br><br>After further thinking of this problem, Mike comes up with a great idea: combining string matching with Boolean algebra! He names it as &quot;Boolean String Expression&quot;.<br><br>Formally, a Boolean String Expression is composed of normal strings, &#xFFFD;&#xFFFD;&amp;&#xFFFD;&#xFFFD;(and), &#xFFFD;&#xFFFD;|&#xFFFD;&#xFFFD;(or) and &#xFFFD;&#xFFFD;!&#xFFFD;&#xFFFD;(not). A Boolean String Expression s matches a message M when:<br>1. s is a normal string, and it&apos;s a substring of M<br>2. s = a &amp; b, a and b are both Boolean String Expressions that match M<br>3. s = a | b, a and b are both Boolean String Expressions, and at least one of them matches M<br>4. s = ! a, a is Boolean String Expression which doesn&apos;t match M<br><br>Precedence of the three operators is: &#xFFFD;&#xFFFD;!&#xFFFD;&#xFFFD; &gt; &#xFFFD;&#xFFFD;&amp;&#xFFFD;&#xFFFD; &gt; &#xFFFD;&#xFFFD;|&#xFFFD;&#xFFFD;. And parenthesis can be used to change precedence of operators. Mike&apos;s query can be easily expressed as:<br>bike &amp; (sell | !buy)<br>Mike is very satisfied with this solution, but he comes to another problem: nearly all expressions can be changed into another form with the same meaning. For example, &quot;bike &amp; (sell | !buy)&quot; has a equivalent form of:<br>(bike &amp; sell) | (bike &amp; !buy)<br>It may seem to be obvious to you. However, it confuses Mike a lot and he needs your help to write a problem to check whether two Boolean String Expressions are equivalent. (Equivalent here means: all messages that match one expression will match the other, all messages that don&apos;t match one expression will not match the other too)<br><br>","type":"description","format":"html"},{"title":"Input","content":"The first line contains an integer indicating the number of test cases (&lt;=30).<br>Each test case contains three lines: The first line is an alphabet that contains only lower case letters. Suppose all messages we care about are only composed of those letters. The second line and 3rd line are two Boolean String Expressions. The expression contains only characters from the alphabet and &apos;&amp;&apos;, &apos;|&apos;, &apos;!&apos; , and its length is no more than 20.<br><br>","type":"input_format","format":"html"},{"title":"Output","content":"For each test case, output a line of &apos;Yes&apos; if the two expressions are equivalent, &apos;No&apos; otherwise.<br>","type":"output_format","format":"html"},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">4\nabcdefghijklmnopqrstuvwxyz\nbike&amp;(sell|!buy)\nbike&amp;sell|bike&amp;!buy\nabc\na&amp;(b|c)\na&amp;b|c\nab\nab&amp;!a\nab&amp;!b\nab\na|b\na|!a</div></pre>","type":"example","format":"html"},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">Yes\nNo\nYes\nNo\n\n<div style=\"font-family:Times New Roman;font-size:14px;background-color:F4FBFF;border:#B7CBFF 1px dashed;padding:6px\"><div style=\"font-family:Arial;font-weight:bold;color:#7CA9ED;border-bottom:#B7CBFF 1px dashed\"><i>Hint</i></div>\nCase 3: Both expressions match nothing, so they are equivalent.\nCase 4: Both expressions match all non-empty messages. However, the second expression can match an empty message, while the first one can&#xFFFD;&#xFFFD;t.\n\n</div><i style=\"font-size:1px\"> </i></div></pre>","type":"example","format":"html"},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=2010+Asia+Regional+Hangzhou+Site+%A1%AA%A1%AA+Online+Contest&amp;source=1&amp;searchmode=source\"> 2010 Asia Regional Hangzhou Site &#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD; Online Contest </a> ","type":"source","format":"html"}]}