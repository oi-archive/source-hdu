{"title":"Programming the EDSAC","time_limit":1000,"memory_limit":32,"operation":{"submit":"http://acm.hdu.edu.cn/submit.php?pid=4238","submissions":"http://acm.hdu.edu.cn/status.php?first=&pid=4238&user=&lang=0&status=0","statistics":"http://acm.hdu.edu.cn/statistic.php?pid=4238","discussion":"http://acm.hdu.edu.cn/discuss/problem/list.php?problemid=4238"},"statement":[{"title":"Problem Description","content":"The world&apos;s first full-scale, stored-program, electronic, digital computer was the EDSAC (Electronic Delay Storage Automatic Calculator). The EDSAC had an accumulator-based instruction set, operating on 17-bit words(and 35-bit double words), and used a 5-bit teletypewriter code for input and output.<br><br>The EDSAC was programmed using a very simple assembly language: a single letter opcode followed by an unsigned decimal address, followed by the the letter &quot;F&quot;(for full word) or &quot;D&quot;(for double word). For example, the instruction &quot;A 128 F&quot; would mean &quot;add the full word at location 128 to the accumulator&quot;, and would be assembled into the 17-bit binary value, 11100000100000000, consisting of a 5-bit opcode(11100=&quot;add&quot;), an 11-bit operand (00010000000 = 128), and a single 0 bit denoting a full word operation(a 1 bit would indicate a double word operation).<br><br>Although arithmetic on the EDSAC was fixed point two&apos;s complement binary, it was not mere intger arithmetic (as is common with modern machines). The EDSAC hardware assumed a binary point between the lrftmost bit and its immediate successor. Thus the hardware could handle only values in the range -1.0 &lt;= x &lt; 1.0 . For example:<br><center><img style=\"max-width:100%;\" src=\"../../data/images/C397-1003-1.jpg\"></center><br>As you can see, the largest possible positive value was:<br><center><img style=\"max-width:100%;\" src=\"../../data/images/C397-1003-2.jpg\"></center><br>and the smallest possible positive value was:<br><center><img style=\"max-width:100%;\" src=\"../../data/images/C397-1003-3.jpg\"></center><br>(This also happens to be the increment between successive values on the EDSAC).<br>By a curious coincidence(or an elegant design decision), the opcode for the add operation(11100) was the same as the teleprinter code for the letter&quot;A&quot;. The opcode for subtract was the same as the teleprinter code for &quot;S&quot;(01100), and so on. This simplified the programming for the assembler (which, incidentally, was a mere 31 instructions long). The EDSAC teleprinter alphabet was &quot;PQWERTYUIOJ#SZK*?F@D!HNM&amp;LXGABCV&quot;(with &quot;P&quot;=00000, &quot;Q&quot;=00001, and so on, up to &quot;V&quot;=11111)<br>UNfortunately, the EDSAC assembler had no special directives for data values. On the other hand, there was no reason that ordinary instructions couldn&apos;t be used for this , thus, an EDSAC programmer desiring to reserve space for the constant 3/4(represented as 01100000000000000) would use the instruction &quot;S O F&quot; and for 1/3(which is approximately represented as 00101010101010101)&quot;T 682 D&quot;, and so on.<br>Your job is to write a program that will translate decimal input value into the appropriate EDSAC instructions.<br>","type":"description","format":"html"},{"title":"Input","content":"The frist line of input contains a single integer P,(1&lt;=P&lt;=1000),which is the number of data sets that follow. Each data set is a single line that contains of two space separated values N and D. N is the data set number. D is the decimal number of the from sd.ddd...., where s is an optional minus sign, and d is any decimal digit(0,-9). There will be at least 1 and at most 16 digits after the decimal point.","type":"input_format","format":"html"},{"title":"Output","content":"For each data set there is one line of output. It contains the data set number(N)followed by a single space, followed by the EDSAC instruction necessary to specify the given constant. The instruction should be printed as follows:the&quot;opcode&quot;character followed by a space followed by the operand(as a non-negative decimal integer)followed by a space followed by an&apos;F&apos;or&apos;D&apos;(as appropriate). If the constant cannot be represented exactly in 17 bits,the value is to be rounded toward zero(up for negative,down for positive numbers). If the input value D is not in the range -1.0 &lt;= D &lt;= 1.0, the string&quot;INVALID VALUE&quot;should be printed instead of an EDSAC instruction.<br>","type":"output_format","format":"html"},{"title":"Sample Input","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">16 \n1 0.5\n2 -0.5\n3 -1.0000000\n4 0.1\n5 0.0000152587890625\n6 0.0000152587890624\n7 0.0000152587890626\n8 -0.0000152587890625\n9 -0.0000152587890624\n10 -0.0000152587890626\n11 0.9999999999999999\n12 -0.9999999999999999\n13 -5.3\n14 9.1\n15 -1.0000000000000001\n16 0.31415926</div></pre>","type":"example","format":"html"},{"title":"Sample Output","content":"<pre><div style=\"font-family:Courier New,Courier,monospace;\">1 I 0 F \n2 &amp; 0 F\n3 ? 0 F\n4 Q 1228 D\n5 P 0 D \n6 P 0 F\n7 P 0 D \n8 V 2047 D\n9 P 0 F\n10 V 2047 D \n11 * 2047 D \n12 ? 0 D \n13 INVALID VALUE\n14 INVALID VALUE\n15 INVALID VALUE\n16 T 54 F</div></pre>","type":"example","format":"html"},{"title":"Source","content":" <a href=\"/search.php?field=problem&amp;key=2011+Greater+New+York+Regional+&amp;source=1&amp;searchmode=source\"> 2011 Greater New York Regional  </a> ","type":"source","format":"html"}]}